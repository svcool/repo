#Базовые функции цифрового ввода/вывода
void pinMode(uint8_t pin, uint8_t mode) — устанавливает режим работы заданного
вход/выхода(pin) как входа или как выхода
Параметры:
● pin: номер вход/выхода(pin), который Вы хотите установить
● mode: режим одно из двух значение - INPUT или OUTPUT, устанавливает на вход или выход соответственно
Возвращаемое значение: нет

void digitalWrite(uint8_t pin, uint8_t value) — подает HIGH (близкое к напряжению
питания) или LOW (близкое к нулю) значение на цифровой вход/выход (pin). Если
вход/выход (pin) был установлен в режим вход (INPUT), то функция digitalWrite со
значением HIGH будет активировать внутренний подтягивающий резистор
номиналом около 20 кОм
Параметры:
● pin: номер вход/выхода(pin)
● value: значение HIGH или LOW
Возвращаемое значение: нет

int digitalRead(uint8_t pin) — возвращает значение с заданного входа - HIGH или
LOW
Параметры:
● pin: номер вход/выхода(pin), который Вы хотите считать
Возвращаемое значение: HIGH или LOW

unsigned long millis(void) — возвращает количество миллисекунд с момента начала
выполнения текущей программы на плате Arduino. Это количество сбрасывается
на ноль из-за переполнения приблизительно через 50 дней.
Параметры: нет
Возвращаемое значение:
● количество миллисекунд с момента начала выполнения программы

unsigned long micros(void) — возвращает количество микросекунд с момента начала
выполнения текущей программы на плате Arduino. Значение переполняется и
сбрасывается в ноль приблизительно через 70 минут
Параметры: нет
Возвращаемое значение:
● количество микросекунд с момента начала выполнения программы

void delay(unsigned long ms) — останавливает выполнение программы на заданное
в параметре количество миллисекунд
Параметры:
● ms: количество миллисекунд, на которое приостанавливается выполнение программы
Возвращаемое значение: нет

void delayMicroseconds(unsigned int us) — останавливает выполнение программы на
заданное в параметре количество микросекунд. Максимальная пауза
воспроизводимая корректно — 16383
Параметры:
● us: количество микросекунд, на которое приостанавливается выполнение программы
Возвращаемое значение: нет

#Как функции цифрового ввода/вывода связаны с регистрами

void pinMode(uint8_t pin, uint8_t mode) — модифицирует значение в
соответствующем регистре DDRx
digitalWrite(uint8_t pin, uint8_t value) — модифицирует значение в соответствующем
регистре PORTx
int digitalRead(uint8_t pin) — считывает значение из соответствующего регистра PINx

void analogWrite(uint8_t pin, int val) — формирует ШИМ сигнал на порте
ввода/вывода. После вызова analogWrite() на выходе будет генерироваться
периодический сигнал с частотой примерно 490 Гц с заданной шириной импульса
до следующего вызова analogWrite() (или вызова digitalWrite() или digitalRead() на
том же порту вход/выхода)
Параметры:
● pin: номер вход/выхода(pin), допустимые значения для польшинства плат: 3, 5, 6, 9, 10, 11
● value: период рабочего цикла значение между 0 (полностью выключено) and 255 (сигнал подан постоянно)
Возвращаемое значение: нет

//Программное подавление дребезга контактов
const int led = 9; //светодиод подключен к контакту 9
const int button = 2; //кнопка подключена к контакту 2
int lastButton = LOW; //предыдущее состояние кнопки
int curButton = LOW; //Текущее состояние кнопки
int ledOn = LOW; //Текущее состояние светодиода
/*Функция подавления дребезга
last - предыдущее состояние кнопки*/
int debounce (int last)
{
int current = digitalRead(button);
if(last != current) //если состояние изменилось
{
delay(5);
current = digitalRead(button);
}
return current;
}
void setup()
{
pinMode(led, OUTPUT); //контакт светодиода - выход
digitalWrite(led, LOW); //на выходе лог. 0
pinMode(button, INPUT); //контакт кнопки - вход
digitalWrite(button, HIGH); //подтягивающий резистор на входе
}
void loop()
{
curButton = debounce (lastButton);
if(lastButton == HIGH && curButton == LOW) //условие нажатия
{
ledOn = !ledOn;
digitalWrite(led, ledOn);
}
lastButton = curButton;
}

#Плавное изменение яркости светодиода
const int led = 9; //светодиод подключен к контакту 9
void setup()
{
pinMode(led, OUTPUT); //контакт светодиода - выход
digitalWrite(led, LOW); //на выходе лог. 0
}
void loop()
{
for(int i = 0; i < 256; i++)
{
analogWrite(led,i);
delay(10);
}
for(int i = 255; i >= 0; i--)
{
analogWrite(led,i);
delay(10);
}
}

#Функции аналогового ввода/вывода

int analogRead(uint8_t pin) — считывает значение с указанного аналогового входа
Параметры:
● pin: номер порта аналогового входа с которого будет производиться считывание, допустимые значения
для польшинства плат: 0 ... 5
Возвращаемое значение:
● цифровой код в диапазоне от 0 до 1023, пропорциональный аналоговому напряжению на входе

void analogReference(uint8_t mode) — определяет опорное напряжение
относительно которого происходят аналоговые измерения
Параметры:
● mode: определяет используемое опорное напряжение
○ DEFAULT: стандартное опорное напряжение 5 В (на платформах с напряжением питания 5 В) или
3,3 В (на платформах с напряжением питания 3,3 В)
○ INTERNAL: встроенное опорное напряжение 1,1 В на микроконтроллерах ATmega168 и
ATmega328, и 2,56 В на ATmega8
○ EXTERNAL: внешний источник опорного напряжения, подключенный к выводу AREF
Возвращаемое значение: нет

long map(long x, long in_min, long in_max, long out_min, long out_max) —
пропорционально переносит значение (x) из текущего диапазона значений
(in_min ... in_max) в новый диапазон (out_min ... out_max), заданный параметрами
Параметры:
● x: значение для переноса
● in_min: нижняя граница текущего диапазона
● in_max: верхняя граница текущего диапазона
● out_min: нижняя граница нового диапазона, в который переноситься значение
● out_max: верхняя граница нового диапазона
Возвращаемое значение: значение в новом диапазоне

#Библиотека Keypad для работы с клавиатурой

Keypad(char *userKeymap, byte *row, byte *col, byte numRows, byte numCols) —
конструктор, создающий объект Keypad
Параметры:
● userKeymap: указатель на массив, хранящий коды клавиш
● row: указатель на массив, хранящий номера выводов строк
● col: указатель на массив, хранящий номера выводов столбцов
● numRows: количество строк
● numCols: количество столбцов
Возвращаемое значение: нет

void begin(char *userKeymap) — инициализирует внутреннюю раскладку клавиатуры,
чтобы та соответствовала userKeymap
Параметры:
● userKeymap: указатель на массив, хранящий коды клавиш
Возвращаемое значение: нет
char waitForKey() — ожидание нажатия клавиши. Предупреждение: она блокирует
весь остальной кода, пока клавиша не будет нажата
Параметры: нет
Возвращаемое значение: код нажатой клавиши

char getKey() — возвращает код нажатой клавиши, если такая есть. Данная функция
неблокирующая
Параметры: нет
Возвращаемое значение: код нажатой клавиши

KeyState getState() — возвращает текущее состояние любой из клавиш
Параметры: нет
Возвращаемое значение: одно из четырех состояний: IDLE, PRESSED, RELEASED и
HOLD

bool keyStateChanged() — сообщает об изменении состояния любой из клавиш.
Например, вместо проверки нужной клавиши, можно проверить, когда клавиша
была нажата
Параметры: нет
Возвращаемое значение: true - было изменение стояния, false - без изменения

void setHoldTime(uint hold) — устанавливает количество миллисекунд, которое
пользователь должен удерживать кнопку нажатой, чтобы было вызвано состояние
HOLD
Параметры:
● hold: время в мс
Возвращаемое значение: нет

void setDebounceTime(uint debounce) — устанавливает количество миллисекунд,
которое клавиатура ждет перед тем, как применить новое нажатие кнопки или
событие кнопки. Это «время задержки» в методе обработки дребезга контактов.
Параметры:
● debounce: время в мс
Возвращаемое значение: нет

void addEventListener(void (*listener)(char)) — подключает функцию обратного вызова
для обработки нажатия клавиши
Параметры:
● listener: имя функции обратного вызова
Возвращаемое значение: нет

#include "Keypad.h"
const byte Rows= 4; // количество строк на клавиатуре
const byte Cols= 4; // количество столбцов на клавиатуре
// определяем массив символов соответствующий распределению кнопок на клавиатуре:
char keymap[Rows][Cols]=
{
{'1', '2', '3', 'A'},
{'4', '5', '6', 'B'},
{'7', '8', '9', 'C'},
{'*', '0', '#','D'}
};
// соединения клавиатуры с выводами Arduino:
byte rPins[Rows]= {11,10,9,8};
byte cPins[Cols]= {7,6,5,4};
// создаем объект класса Keypad
Keypad kpd= Keypad(makeKeymap(keymap), rPins, cPins, Rows, Cols);
void setup()
{
Serial.begin(9600); // инициализация монитора последовательного порта
}
// Если кнопка нажата, эта кнопка сохраняется в переменной keypressed.
// Если keypressed не равна NO_KEY, то выводим значение в последовательный порт.
void loop()
{
char keypressed = kpd.getKey();
if (keypressed != NO_KEY)
{
Serial.println(keypressed);
}
}

#Формирование символа на индикаторе
Макрофункции для битовых операций
bitRead(value, bit) — возвращает значение конкретного разряда числа
Параметры:
● value: число (любой целочисленный тип)
● bit: номер разряда (любой целочисленный тип)
Возвращаемое значение: значение разряда (0 или 1)
bitSet(value, bit) — устанавливает в 1 конкретный разряд числа
Параметры:
● value: число (любой целочисленный тип)
● bit: номер разряда (любой целочисленный тип)
Возвращаемое значение: нет
bitClear(value, bit) — сбрасывает в 0 конкретный разряд числа
Параметры:
● value: число (любой целочисленный тип)
● bit: номер разряда (любой целочисленный тип)
Возвращаемое значение: нет
bitWrite(value, bit, bitvalue) — устанавливает или сбрасывает конкретный разряд
числа
Параметры:
● value: число (любой целочисленный тип)
● bit: номер разряда (любой целочисленный тип)
● bitvalue: устанавливаемое значение: 0 или 1
Возвращаемое значение: нет

#define SEG_COUNT 7 //количество используемых сегментов
const int firstSeg = 2; //младший номер вывода для подключения индикатора
// Таблица перекодировки символов
byte numberSegments[10] = {
0b11000000, //0
0b11111001, //1
0b10100100, //2
0b10110000, //3
0b10011001, //4
0b10010010, //5
0b10000010, //6
0b11111000, //7
0b10000000, //8
0b10010000, //9
};
void setup()
{
for (int i = 0; i < SEG_COUNT; ++i)
pinMode(i + firstSeg, OUTPUT);
}
void loop()
{
int number, mask;
boolean enableSegment;
// число для отображения - количество секунд
number = (millis() / 1000) % 10;
// код символа из таблицы перекодировки
mask = numberSegments[number];
// для каждого сегмента определяем: должен ли он быть включён.
for (int i = 0; i < SEG_COUNT; i++)
{
enableSegment = bitRead(mask, i);
digitalWrite(i + firstSeg, enableSegment);
}
}

#Библиотека fDigitsSegtPin для работы с многоразрядным семисегметным индикатором
fDigitsSegtPin(u8 vPf1, u8 vPf2, u8 vPf3, u8 vPf4, u8 vPf5, u8 vPf6, u8 vPf7, u8 vPf8, u8
vPf9, u8 vPf10, u8 vPf11, u8 vPf12) — конструктор, создающий объект fDigitsSegtPin
Параметры:
● vPf1: номер вывода для сегмента E; vPf2: номер вывода для сегмента D;
● vPf3: номер вывода для сегмента H; vPf4: номер вывода для сегмента C;
● vPf5: номер вывода для сегмента G; vPf6: номер вывода для 4-го индикатора;
● vPf7: номер вывода для сегмента B; vPf8: номер вывода для 3-го индикатора;
● vPf9: номер вывода для 2-го индикатора; vPf10: номер вывода для сегмента F;
● vPf11: номер вывода для сегмента A; vPf12: номер вывода для 1-го индикатора;
Возвращаемое значение: нет

# Библиотека fDigitsSegtPin для работы с индикатором
void begin() — инициализирует заданные в конструкторе выводы для работы с
Параметры: нет
Возвращаемое значение: нет

void print(float vff) — выводит на индикатор нужное значение. Необходимо
периодически вызывать функцию в бесконечном цикле для работы динамической
индикации.
Параметры:
● vff: число, выводимое на индикатор (диапазон от 0 до 9999)
Возвращаемое значение: нет

u8 doPrint_lastDot — поле, задающее необходимость вывода точки в конце числа:
0 - не выводить, 1 - выводить

u8 doPrint_firstZero — поле, задающее необходимость вывода лидирующих нулей:
0 - не выводить, 1 - выводить

doReport_overRange — поле, задающее необходимость вывода сообщения о
выходе из диапазона допустимых значения для отображения через COM-порт:
0 - не выводить, 1 - выводить

#include <fDigitsSegtPin.h> // Подключаем библиотеку
fDigitsSegtPin
// Инициализируем объект-4-х разрядный индикатор, передаём
использованные
// для подключения контакты на:
fDigitsSegtPin Display(6, 5, 9, 4, 8, 13, 3, 12, 11, 7, 2, 10);
void setup()
{
Display.begin();
}
void loop()
{
static unsigned long timer = millis(); //текущее время
static float deciSeconds = 0; //время, отображаемое на индикаторе
if (millis() - timer >= 100) //прошло 100 мс
{
timer += 100;
deciSeconds += 0.1; // 100 мс = 0,1 сек
if (deciSeconds >= 1000) // выход из диапазона
{
deciSeconds = 0;
}
}
Display.print(deciSeconds); //периодический вызов функции в основном цикле
}

#Подключение жидкокристаллического индикатора
Назначение контактов:
● VSS: «-» питание модуля
● VDD: «+» питание модуля
● VO: Вывод управления контрастом
● RS: Выбор регистра
● RW: Выбор режима записи или чтения (при
подключении к земле, устанавливается режим
записи)
● E: Строб по спаду
● DB0-DB3: Биты интерфейса
● DB4-DB7: Биты интерфейса
● A: «+» питание подсветки
● K: «-» питание подсветки
#Библиотека LiquidCrystal для работы с жидкокристаллическим индикатором
LiquidCrystal(uint8_t rs, uint8_t enable,
uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3,
uint8_t d4, uint8_t d5, uint8_t d6, uint8_t d7);
LiquidCrystal(uint8_t rs, uint8_t rw, uint8_t enable,
uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3);
LiquidCrystal(uint8_t rs, uint8_t enable,
uint8_t d0, uint8_t d1, uint8_t d2, uint8_t d3); — конструкторы, создающий
объект LiquidCrystal
Параметры:
● rs, rw, enable, d0 - d7: номер вывода Arduino, подключаемый к соответствующему выводу индикатора
Возвращаемое значение: нет

void begin(uint8_t cols, uint8_t rows, uint8_t charsize = LCD_5x8DOTS) —
инициализирует интерфейс для взаимодействия с LCD-экраном и задает размеры
(ширину и высоту) области вывода экрана
Параметры:
● cols: количество столбцов экрана;
● rows: количество строк экрана;
● charsize: размер символа
Возвращаемое значение: нет

void clear() — очищает LCD-экран и перемещает курсор в левый верхний угол
Параметры: нет
Возвращаемое значение: нет
void home() — перемещает курсор в левый верхний угол экрана
Параметры: нет
Возвращаемое значение: нет
void noDisplay() — выключает LCD-экран. Текст сохраняется в памяти
Параметры: нет
Возвращаемое значение: нет

void display() — включает LCD-экран после того, как он был выключен функцией
noDisplay(). После выполнения этой функции на экране отобразится текст (и
курсор), которые были на нем до выключения
Параметры: нет
Возвращаемое значение: нет
void noBlink() — отключает отображение мигающего курсора на LCD-экране
Параметры: нет
Возвращаемое значение: нет

void blink() — включает на LCD-экране мигающий курсор
Параметры: нет
Возвращаемое значение: нет
void noCursor() — отключает отображение курсора на LCD-экране
Параметры: нет
Возвращаемое значение: нет
void cursor() — отображает на LCD-экране курсор, куда будет выведен символ
Параметры: нет
Возвращаемое значение: нет

void scrollDisplayLeft() — осуществляет прокрутку содержимого дисплея (весь текст
и курсор) на один символ влево
Параметры: нет
Возвращаемое значение: нет
void scrollDisplayRight() — Осуществляет прокрутку содержимого дисплея (весь
текст и курсор) на один символ вправо
Параметры: нет
Возвращаемое значение: нет
void leftToRight() — устанавливает режим вывода текста на LCD слева-направо
(режим по умолчанию)
Параметры: нет
Возвращаемое значение: нет

void rightToLeft() — устанавливает режим вывода текста на LCD справа-налево
Параметры: нет
Возвращаемое значение: нет
void autoscroll() — включает автоматическую прокрутку текста на LCD. При выводе
нового символа, все предыдущие символы будут сдвигаться на одну позицию
Параметры: нет
Возвращаемое значение: нет
void noAutoscroll() — отключает автоматическую прокрутку текста в LCD
Параметры: нет
Возвращаемое значение: нет
void createChar(uint8_t location, uint8_t charmap[]) — создает пользовательский
символ для LCD-экрана. Дисплей поддерживает до 8 пользовательских символов
(пронумерованных от 0 до 7) размером 5х8 пикселей
Параметры:
● location: номер пользовательского символа, который необходимо создать (от 0 до 7);
● charmap: данные о пикселях пользовательского символа
Возвращаемое значение: нет
void setCursor(uint8_t col, uint8_t row) — задает позицию курсора на LCD-экране
Параметры:
● col: координата X позиции курсора (0 означает первый столбец);
● row: координата Y позиции курсора (0 означает первую строку)
Возвращаемое значение: нет
size_t write(uint8_t value) — выводит символ на LCD-экран
Параметры:
● value: символ, который необходимо вывести на экран
Возвращаемое значение: количество отправленных байт

#include <LiquidCrystal.h> // Подключаем стандартную библиотеку LiquidCrystal
// Инициализируем объект-экран, передаём использованные
// для подключения контакты на Arduino в порядке:
// RS, E, D4, D5, D6, D7
LiquidCrystal lcd(12, 11, 10, 9, 8, 7);
const int potPin = A0; // потенциометр
const int ledPin = 6; // светодиод на выводе с ШИМ
int potValue = 0; // значение от потенциометра
int brightness = 0; // конвертируем в яркость
int progress = 0; // индикатор прогресса
//Пользовательский символ
byte pBar[8] =
{
B11111,
B11111,
B11111,
B11111,
B11111,
B11111,
B11111,
};
void setup()
{
// устанавливаем размер (количество столбцов и строк) экрана
lcd.begin(16, 2);
// светодиод
pinMode(ledPin, OUTPUT);
// Выводим сообщение в первой строчке
lcd.print(" LED Brightness");
// Создаем символы для индикатора прогресса
lcd.createChar(0, pBar);
// ощищаем экран
lcd.clear();
// выводим сообщение в первой строчке
lcd.print(" LED Brightness");
}
void loop()
{
static int oldProgress = 0; //старое значение на экране
potValue = analogRead(potPin); // считываем показания с потенциометра
brightness = map(potValue, 0, 1024, 0, 255); // конвертируем значения в яркость от 0 до 255
analogWrite(ledPin, brightness); // меняем яркость светодиода в зависимости от значений от потенциометра
progress = map(brightness, 0, 255, 0, 17); // конвертируем значения яркость в проценты для индикатора от 0 до 17
if(progress != oldProgress) //данные изменились
{
oldProgress = progress;
lcd.setCursor(0, 1); // устанавливаем курсор на второй строчке
lcd.print(" "); // очищаем экран (16 пробелов)
for (int i = 0; i < progress; i++) // выводим индикатор
{
lcd.setCursor(i, 1);
lcd.write(byte(0));
}
}
}